{"version":3,"sources":["../src/index.ts","../src/engine/MapEngine.ts","../src/providers/google/GoogleMapEngine.ts","../src/engine/motion/NetworkBuffer.ts","../src/utils/geo.ts","../src/engine/motion/PhysicsModel.ts","../src/engine/motion/ConfidenceModel.ts","../src/engine/motion/IntentModel.ts","../src/engine/motion/MotionEngine.ts","../src/engine/controllers/LiveMotionController.ts","../src/engine/controllers/TripReplayController.ts"],"sourcesContent":["export type {\n    VehicleLike,\n    ThemeName,\n    IconConfig,\n    IconResolver,\n    InfoWindowRenderer,\n    MapEngineOptions\n} from './engine/types.js';\n\nexport { MapEngine } from './engine/MapEngine.js';\nexport { GoogleMapEngine } from './providers/google/GoogleMapEngine.js';\nexport { TripReplayController } from './engine/controllers/TripReplayController.js';\nexport { LiveMotionController } from './engine/controllers/LiveMotionController.js';\n\n\nexport type {\n    GeoPoint,\n    LatLng\n} from './utils/geo.js';\n\nexport {\n    haversineDistance,\n    computeBearing,\n    extrapolatePosition,\n    lerpPosition\n} from './utils/geo.js';\n","import type { MapEngineOptions, ThemeName, VehicleLike } from './types.js';\n\n/**\n * Abstract base class for Map Engines (e.g., Google Maps, Leaflet, Mapbox).\n * Defines the contract for interacting with the map.\n */\nexport abstract class MapEngine {\n    protected options: MapEngineOptions;\n\n    constructor(options: MapEngineOptions) {\n        this.options = options;\n    }\n\n    /**\n     * Initializes and mounts the map to the specified DOM element.\n     * @param element The container ID or HTMLElement.\n     */\n    abstract mount(element: string | HTMLElement): Promise<any>;\n\n    /**\n     * Adds a marker for a vehicle.\n     */\n    abstract addVehicleMarker(vehicle: VehicleLike): void;\n\n    /**\n     * Updates an existing vehicle marker (position, icon, content).\n     */\n    abstract updateVehicleMarker(vehicle: VehicleLike): void;\n\n    /**\n     * Removes a vehicle marker by ID.\n     */\n    abstract removeMarker(id: string | number): void;\n\n    /**\n     * Removes all markers from the map.\n     */\n    abstract clearAllMarkers(): void;\n\n    /**\n     * Centers the map to fit the given vehicles.\n     */\n    abstract centerOnVehicles(vehicles: VehicleLike[]): void;\n\n    /**\n     * Centers the map on a specific vehicle/location.\n     */\n    abstract setCenter(lat: number, lng: number): void;\n\n    /**\n     * Sets the zoom level.\n     */\n    abstract setZoom(zoom: number): void;\n\n    /**\n     * Draws a polyline for a trip/route.\n     */\n    abstract drawTripPolyline(coordinates: any[]): void;\n\n    /**\n     * Clears the current trip polyline.\n     */\n    abstract clearTripPolyline(): void;\n\n    /**\n     * Animates a vehicle along a path.\n     */\n    abstract animateTrip(coordinates: any[], totalDuration?: number, onFinish?: () => void): void;\n\n    /**\n     * Stops any active trip animation.\n     */\n    abstract stopTripAnimation(): void;\n\n    /**\n     * Updates the map theme.\n     */\n    setTheme(theme: ThemeName): void {\n        this.options.theme = theme;\n        this.onThemeChange(theme);\n    }\n\n    /**\n     * Internal method to handle theme changes in the specific implementation.\n     */\n    protected abstract onThemeChange(theme: ThemeName): void;\n\n    /**\n     * Starts the live tracking animation loop.\n     */\n    abstract startLive(): void;\n\n    /**\n     * Stops the live tracking animation loop to save resources.\n     */\n    abstract stopLive(): void;\n\n    /**\n     * Cleans up resources.\n     */\n    abstract dispose(): void;\n}\n","/// <reference types=\"@types/google.maps\" />\nimport { setOptions, importLibrary } from '@googlemaps/js-api-loader';\nimport { MapEngine } from '../../engine/MapEngine.js';\nimport type { MapEngineOptions, ThemeName, VehicleLike, IconConfig, LiveMotionInput, SvgIconConfig } from '../../engine/types.js';\nimport { LiveMotionController } from '../../engine/controllers/LiveMotionController.js';\nimport { TripReplayController } from '../../engine/controllers/TripReplayController.js';\nimport type { MarkerAdapter } from '../../engine/interfaces/MarkerAdapter.js';\n\n\n\n\nfunction buildSvgIcon(config: SvgIconConfig): google.maps.Symbol {\n    return {\n        path: config.path,\n        fillColor: config.fillColor || '#FFFFFF',\n        fillOpacity: config.fillOpacity ?? 1,\n        strokeColor: config.strokeColor || 'transparent',\n        strokeWeight: config.strokeWeight ?? 0,\n        scale: config.scale ?? 1,\n        anchor: config.anchor ? new google.maps.Point(config.anchor.x, config.anchor.y) : null\n    };\n}\n\nexport class GoogleMapEngine extends MapEngine {\n    private map: google.maps.Map | null = null;\n    private googleApi: typeof google | null = null;\n    private markers = new Map<string | number, { marker: google.maps.Marker; infoWindow: google.maps.InfoWindow }>();\n\n    // Controllers\n    private liveController: LiveMotionController;\n    private tripController: TripReplayController | null = null;\n    private markerAdapter: MarkerAdapter;\n\n    constructor(options: MapEngineOptions) {\n        super(options);\n\n        const lastRotation = new Map<string | number, number>();\n\n        this.markerAdapter = {\n            setMarkerPosition: (id, lat, lng) => {\n                const m = this.markers.get(id)?.marker;\n                if (m && this.googleApi) {\n                    m.setPosition(new this.googleApi.maps.LatLng(lat, lng));\n                }\n            },\n            setMarkerRotation: (id, bearing) => {\n                const m = this.markers.get(id)?.marker;\n                if (!m) return;\n\n                // If PNG, don't rotate\n                const icon: any = m.getIcon();\n                if (!icon) return;\n\n                if (icon.url) return; // PNG/Image, ignoring\n\n                // Check if it is a symbol\n                if (typeof icon === 'object' && icon.path) {\n                    // Update rotation only\n                    const newIcon = { ...icon, rotation: bearing };\n                    m.setIcon(newIcon);\n                }\n\n                // Basic throttle logic remains...\n                const prev = lastRotation.get(id);\n                if (prev !== undefined && Math.abs(prev - bearing) < 2) return;\n                lastRotation.set(id, bearing);\n\n\n            }\n        };\n\n        this.liveController = new LiveMotionController(this.markerAdapter, this.options.liveMotionPolicy);\n        this.liveController.start();\n    }\n\n    async mount(element: string | HTMLElement): Promise<google.maps.Map> {\n        const apiKey = this.options.apiKey || (import.meta as any).env.VITE_GOOGLE_MAPS_API_KEY;\n        if (!apiKey) {\n            throw new Error('Google Maps API Key is required');\n        }\n\n        setOptions({\n            key: apiKey,\n            v: 'weekly',\n            libraries: ['places']\n        });\n\n        await importLibrary('maps');\n        await importLibrary('marker');\n\n        this.googleApi = google;\n\n        const initialTheme: ThemeName = this.options.theme || 'modern';\n        const styles = this.getStylesForTheme(initialTheme);\n        const backgroundColor = this.getBackgroundColorForTheme(initialTheme);\n\n        const mapOptions: google.maps.MapOptions = {\n            backgroundColor: this.options.backgroundColor || backgroundColor,\n            center: this.options.center || { lat: 19.4326, lng: -99.1332 },\n            zoom: this.options.zoom || 13,\n            fullscreenControl: true,\n            streetViewControl: this.options.streetViewControl ?? false,\n            mapTypeControl: false,\n            zoomControl: true,\n            styles: (styles as any) || undefined,\n            disableDefaultUI: true,\n            ...this.options.mapOptions\n        };\n\n        const el = typeof element === 'string' ? document.getElementById(element) : element;\n        if (!el) throw new Error('Map container element not found');\n\n        this.map = new this.googleApi!.maps.Map(el as HTMLElement, mapOptions);\n\n        if (mapOptions.backgroundColor) {\n            this.map.getDiv().style.backgroundColor = mapOptions.backgroundColor;\n        }\n\n        // Initialize TripController now that map is ready\n        this.tripController = new TripReplayController(this.map, this.googleApi);\n\n        return this.map;\n    }\n\n    private getBackgroundColorForTheme(theme: ThemeName): string {\n        switch (theme) {\n            case 'modern': return '#0b1524';\n            case 'dark': return '#0B1524';\n            case 'light': default: return '#0F1115';\n        }\n    }\n\n    private getStylesForTheme(theme: ThemeName): google.maps.MapTypeStyle[] | null {\n        if (this.options.styles && this.options.styles[theme]) {\n            return this.options.styles[theme];\n        }\n        return null;\n    }\n\n    protected onThemeChange(theme: ThemeName): void {\n        console.log('[GoogleMapEngine] onThemeChange called with:', theme);\n        if (this.map) {\n            const styles = this.getStylesForTheme(theme);\n            const backgroundColor = this.getBackgroundColorForTheme(theme);\n            const styleCount = styles ? `${styles.length} rules` : 'Default (null)';\n            console.log(`[GoogleMapEngine] Applying styles: ${styleCount}, bg: ${backgroundColor}`);\n            this.map.setOptions({ styles, backgroundColor });\n            this.map.getDiv().style.backgroundColor = backgroundColor;\n        } else {\n            console.warn('[GoogleMapEngine] Map not initialized, skipping theme update');\n        }\n    }\n\n    private adaptToInput(vehicle: VehicleLike, lat: number, lng: number, id: string | number): LiveMotionInput {\n        const motion: LiveMotionInput['motion'] = {};\n\n        if (vehicle.alert === 'Turn On') motion.ignition = 'on';\n        else if (vehicle.alert === 'Turn Off') motion.ignition = 'off';\n\n        if (vehicle.engine_status !== undefined) {\n            const status = String(vehicle.engine_status).toLowerCase();\n            motion.moving = status === '1' || status === 'true' || status === 'on';\n        }\n\n        const input: LiveMotionInput = {\n            id,\n            lat,\n            lng,\n            speedKmh: Number(vehicle.speed || 0),\n            bearing: Number(vehicle.course || 0),\n            motion\n        };\n\n        if (vehicle.ts) {\n            input.timestamp = Number(vehicle.ts);\n        } else if (vehicle.timestamp) {\n            input.timestamp = Number(vehicle.timestamp);\n        }\n\n        return input;\n    }\n\n    addVehicleMarker(vehicle: VehicleLike): void {\n        if (!this.map || !this.googleApi) return;\n\n        const lat = Number(vehicle.lat || vehicle.latitude);\n        const lng = Number(vehicle.lng || vehicle.longitude);\n        const id = vehicle.id || vehicle.device_id || vehicle.deviceId;\n\n        if (isNaN(lat) || isNaN(lng) || !id) {\n            console.warn('Invalid coords or ID for vehicle', vehicle);\n            return;\n        }\n\n        const position = { lat, lng };\n\n        let iconConfig: IconConfig = { url: '' };\n        if (this.options.iconResolver) {\n            iconConfig = this.options.iconResolver(vehicle);\n        }\n\n        const markerOptions: google.maps.MarkerOptions = {\n            position,\n            map: this.map,\n            title: String(vehicle.device_id || id),\n        };\n\n        if (vehicle.icon) {\n            markerOptions.icon = buildSvgIcon(vehicle.icon);\n        } else if (iconConfig.url) {\n            markerOptions.icon = {\n                url: iconConfig.url,\n                scaledSize: iconConfig.size ? new this.googleApi!.maps.Size(iconConfig.size[0], iconConfig.size[1]) : null,\n                anchor: iconConfig.anchor ? new this.googleApi!.maps.Point(iconConfig.anchor[0], iconConfig.anchor[1]) : null\n            };\n        } else {\n            // Default marker (empty config gives standard pin)\n        }\n\n        const marker = new this.googleApi.maps.Marker(markerOptions);\n\n        let content = '';\n        if (this.options.infoWindowRenderer) {\n            content = this.options.infoWindowRenderer(vehicle);\n        }\n        const infoWindow = new this.googleApi.maps.InfoWindow({ content });\n\n        marker.addListener('click', () => {\n            infoWindow.open(this.map, marker);\n        });\n\n        this.markers.set(id, { marker, infoWindow });\n\n        this.liveController.update(this.adaptToInput(vehicle, lat, lng, id));\n    }\n\n    updateVehicleMarker(vehicle: VehicleLike): void {\n        const id = vehicle.id || vehicle.device_id || vehicle.deviceId;\n        const existing = this.markers.get(id);\n\n        if (!existing) {\n            this.addVehicleMarker(vehicle);\n            return;\n        }\n\n        const lat = Number(vehicle.lat || vehicle.latitude);\n        const lng = Number(vehicle.lng || vehicle.longitude);\n\n        if (!isNaN(lat) && !isNaN(lng)) {\n            if (this.options.infoWindowRenderer) {\n                existing.infoWindow.setContent(this.options.infoWindowRenderer(vehicle));\n            }\n\n            if (vehicle.icon) {\n                existing.marker.setIcon(buildSvgIcon(vehicle.icon));\n            } else if (this.options.iconResolver) {\n                const iconConfig = this.options.iconResolver(vehicle);\n                if (iconConfig.url) {\n                    existing.marker.setIcon({\n                        url: iconConfig.url,\n                        scaledSize: iconConfig.size ? new this.googleApi!.maps.Size(iconConfig.size[0], iconConfig.size[1]) : null,\n                        anchor: iconConfig.anchor ? new this.googleApi!.maps.Point(iconConfig.anchor[0], iconConfig.anchor[1]) : null\n                    });\n                }\n            }\n\n            this.liveController.update(this.adaptToInput(vehicle, lat, lng, id));\n        }\n    }\n\n    removeMarker(id: string | number): void {\n        const data = this.markers.get(id);\n        if (data) {\n            data.marker.setMap(null);\n            this.markers.delete(id);\n        }\n        this.liveController.remove(id);\n    }\n\n    clearAllMarkers(): void {\n        this.markers.forEach(data => data.marker.setMap(null));\n        this.markers.clear();\n\n        // Clear controller state\n        this.liveController.clear();\n    }\n\n    startLive(): void {\n        this.liveController.start();\n    }\n\n    stopLive(): void {\n        this.liveController.stop();\n    }\n\n    centerOnVehicles(vehicles: VehicleLike[]): void {\n        if (!this.map || !this.googleApi || !vehicles.length) return;\n        const bounds = new this.googleApi.maps.LatLngBounds();\n        let hasValid = false;\n        vehicles.forEach(v => {\n            const lat = Number(v.lat || v.latitude);\n            const lng = Number(v.lng || v.longitude);\n            if (!isNaN(lat) && !isNaN(lng)) {\n                bounds.extend({ lat, lng });\n                hasValid = true;\n            }\n        });\n        if (hasValid) {\n            this.map.fitBounds(bounds);\n        }\n    }\n\n    setCenter(lat: number, lng: number): void {\n        if (this.map) {\n            this.map.setCenter({ lat, lng });\n        }\n    }\n\n    setZoom(zoom: number): void {\n        if (this.map) {\n            this.map.setZoom(zoom);\n        }\n    }\n\n    // ==========================================\n    // TRIP POLYLINE & ANIMATION DELEGATION\n    // ==========================================\n\n    drawTripPolyline(coordinates: any[]): void {\n        if (this.tripController) {\n            this.tripController.drawPolyline(coordinates);\n        }\n    }\n\n    clearTripPolyline(): void {\n        if (this.tripController) {\n            this.tripController.clearPolyline();\n        }\n    }\n\n    stopTripAnimation(): void {\n        if (this.tripController) {\n            this.tripController.stop();\n        }\n    }\n\n    animateTrip(coordinates: any[], totalDuration = 10000, onFinish?: () => void): void {\n        if (this.tripController) {\n            this.tripController.load(coordinates);\n            this.tripController.play({ duration: totalDuration }, onFinish);\n        }\n    }\n\n    dispose(): void {\n        this.liveController.stop();\n        if (this.tripController) {\n            this.tripController.stop();\n            this.tripController.clearPolyline();\n        }\n        this.clearAllMarkers();\n        this.map = null;\n    }\n}\n","import type { LiveMotionInput } from '../types.js';\nimport type { NetworkBuffer } from './types.js';\n\n/**\n * A buffer that reorders packets based on timestamp and handles jitter.\n * Currently implements a simple reordering queue.\n * Future improvements could include min-delay buffering.\n */\nexport class SimpleNetworkBuffer implements NetworkBuffer {\n    private buffer: LiveMotionInput[] = [];\n    private lastProcessedTimestamp = 0;\n    private maxBufferSize = 50;\n\n    push(packet: LiveMotionInput): void {\n        const ts = packet.timestamp || Date.now();\n\n        // Discard archaic packets (older than last processed)\n        if (ts < this.lastProcessedTimestamp) {\n            return;\n        }\n\n        this.buffer.push(packet);\n        // Keep sorted by timestamp (oldest first)\n        this.buffer.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));\n\n        // Trim buffer if too large (drop oldest/irrelevant? No, drop from start if we have too many?)\n        // Actually, if we have too many, we might want to drop oldest or snap. \n        // For now, just a hard limit to prevent memory leaks if not popped.\n        if (this.buffer.length > this.maxBufferSize) {\n            this.buffer.shift(); // Drop oldest\n        }\n    }\n\n    pop(): LiveMotionInput | null {\n        if (this.buffer.length === 0) {\n            return null;\n        }\n\n        // In a real jitter buffer, we would wait until we have X ms of data\n        // or check if the gap is too large. \n        // For now, we just return the next available packet in order.\n\n        const next = this.buffer.shift();\n        if (next) {\n            this.lastProcessedTimestamp = next.timestamp || Date.now();\n        }\n        return next || null;\n    }\n\n    getLatestTimestamp(): number {\n        if (this.buffer.length === 0) {\n            return this.lastProcessedTimestamp;\n        }\n        const last = this.buffer[this.buffer.length - 1];\n        return (last && last.timestamp) || this.lastProcessedTimestamp;\n    }\n}\n","export interface GeoPoint {\n    lat: number;\n    lng: number; // standardized to lng but supporting lon for input if needed\n}\n\nexport interface LatLng {\n    lat: number;\n    lng: number;\n}\n\n/**\n * Calculates the distance between two points in meters using the Haversine formula.\n */\nexport function haversineDistance(coords1: { lat: number; lng?: number; lon?: number }, coords2: { lat: number; lng?: number; lon?: number }): number {\n    const R = 6371e3; // metres\n    const lat1 = coords1.lat;\n    const lon1 = coords1.lng ?? coords1.lon ?? 0;\n    const lat2 = coords2.lat;\n    const lon2 = coords2.lng ?? coords2.lon ?? 0;\n\n    const φ1 = (lat1 * Math.PI) / 180; // φ, λ in radians\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δφ = ((lat2 - lat1) * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const a =\n        Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // in metres\n}\n\n/**\n * Computes the bearing (heading) from one point to another in degrees (0-360).\n */\nexport function computeBearing(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const φ1 = (lat1 * Math.PI) / 180;\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const y = Math.sin(Δλ) * Math.cos(φ2);\n    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n\n    return ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;\n}\n\n/**\n * Extrapolates a new position based on start point, speed, bearing and time delta.\n */\nexport function extrapolatePosition(lat: number, lon: number, speedMps: number, bearingDeg: number, deltaSeconds: number): { lat: number; lon: number } {\n    const R = 6378137;\n    const dist = speedMps * deltaSeconds;\n    const δ = dist / R;\n    const θ = (bearingDeg * Math.PI) / 180;\n\n    const φ1 = (lat * Math.PI) / 180;\n    const λ1 = (lon * Math.PI) / 180;\n\n    const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));\n\n    const λ2 =\n        λ1 +\n        Math.atan2(\n            Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),\n            Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2)\n        );\n\n    return {\n        lat: (φ2 * 180) / Math.PI,\n        lon: (λ2 * 180) / Math.PI\n    };\n}\n\n/**\n * Linearly interpolates between two positions.\n */\nexport function lerpPosition(pos1: { lat: number; lon: number }, pos2: { lat: number; lon: number }, t: number): { lat: number; lon: number } {\n    return {\n        lat: pos1.lat + (pos2.lat - pos1.lat) * t,\n        lon: pos1.lon + (pos2.lon - pos1.lon) * t\n    };\n}\n\n/**\n * Linearly interpolates between two angles (in degrees), taking the shortest path.\n */\nexport function lerpAngle(start: number, end: number, t: number): number {\n    const diff = ((end - start + 180) % 360 + 360) % 360 - 180;\n    return (start + diff * t + 360) % 360;\n}\n\n/**\n * Clamps a value between a minimum and maximum.\n */\nexport function clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n}\n","import type { LiveMotionInput } from '../types.js';\nimport { extrapolatePosition } from '../../utils/geo.js';\nimport type { PhysicsModel, MotionPose } from './types.js';\n\nexport class KinematicPhysicsModel implements PhysicsModel {\n    // We keep track of the \"physics\" velocity, which might differ from the last reported speed\n    // if we want to model inertia. For now, we trust the telemetry speed but allow integration.\n    private currentSpeed = 0;\n    private currentHeading = 0;\n\n    step(currentPose: MotionPose, dt: number): MotionPose {\n        // Integrate position\n        const newPos = extrapolatePosition(\n            currentPose.lat,\n            currentPose.lng,\n            this.currentSpeed,\n            this.currentHeading,\n            dt\n        );\n\n        // Simple uncertainty growth (more time = more uncertainty)\n        // e.g. grows by 1 meter per second of blind prediction?\n        const newUncertainty = currentPose.uncertaintyRadius + (this.currentSpeed * 0.1 * dt);\n\n        return {\n            lat: newPos.lat,\n            lng: newPos.lon,\n            heading: this.currentHeading,\n            speed: this.currentSpeed,\n            uncertaintyRadius: newUncertainty\n        };\n    }\n\n    update(observation: LiveMotionInput): void {\n        const speedMs = (observation.speedKmh || 0) * 1000 / 3600;\n        this.currentSpeed = speedMs;\n\n        if (observation.bearing !== undefined) {\n            this.currentHeading = observation.bearing;\n        }\n    }\n}\n","import type { LiveMotionInput, LiveMotionPolicy } from '../types.js';\nimport type { ConfidenceModel, MotionState } from './types.js';\n\nconst DEFAULT_POLICY: LiveMotionPolicy = {\n    fullConfidenceMs: 5000,\n    decayMs: 10000,\n    maxStaleMs: 15 * 60 * 1000\n};\n\nexport class TimeBasedConfidenceModel implements ConfidenceModel {\n    private lastUpdateTime: number = 0;\n    private currentTime: number = 0;\n    private policy: LiveMotionPolicy;\n\n    constructor(policy?: Partial<LiveMotionPolicy>) {\n        this.policy = { ...DEFAULT_POLICY, ...policy };\n    }\n\n    update(observation?: LiveMotionInput): void {\n        const now = Date.now(); // Or use observation timestamp if we are strictly event driven\n        this.lastUpdateTime = now;\n        this.currentTime = now;\n    }\n\n    decay(dt: number): void {\n        // dt is in seconds, convert to ms\n        this.currentTime += (dt * 1000);\n    }\n\n    getConfidence(): number {\n        const age = this.currentTime - this.lastUpdateTime;\n\n        if (age < this.policy.fullConfidenceMs) {\n            return 1.0;\n        } else if (age < (this.policy.fullConfidenceMs + this.policy.decayMs)) {\n            const decayStart = this.policy.fullConfidenceMs;\n            const decayEnd = decayStart + this.policy.decayMs;\n            return 1 - (age - decayStart) / (decayEnd - decayStart);\n        } else {\n            return 0.0;\n        }\n    }\n\n    getState(): MotionState {\n        const age = this.currentTime - this.lastUpdateTime;\n        const confidence = this.getConfidence();\n\n        if (age < this.policy.fullConfidenceMs) {\n            return 'REAL';\n        } else if (confidence > 0) {\n            return 'COASTING';\n        } else if (age > this.policy.maxStaleMs) {\n            return 'FROZEN';\n        } else {\n            // In the gap between decay end and maxStale, we are \"Predicted\" but with 0 confidence?\n            // Or maybe \"Frozen\"? \n            // Let's call it PREDICTED if we are still moving technically, but confidence is low.\n            // Actually, if confidence is 0, we shouldn't trust position. \n            // But let's follow the buckets.\n            return 'PREDICTED';\n        }\n    }\n}\n","import type { LiveMotionInput } from '../types.js';\nimport type { IntentModel, Intent } from './types.js';\n\nexport class VarianceIntentModel implements IntentModel {\n    private recentBearings: number[] = [];\n    private windowSize = 5;\n\n    update(observation: LiveMotionInput): void {\n        if (observation.bearing !== undefined) {\n            this.recentBearings.push(observation.bearing);\n            if (this.recentBearings.length > this.windowSize) {\n                this.recentBearings.shift();\n            }\n        }\n    }\n\n    getIntent(): Intent {\n        if (this.recentBearings.length < 2) {\n            return { action: 'UNKNOWN', confidence: 0 };\n        }\n\n        const variance = this.calculateCircularVariance(this.recentBearings);\n\n        // Thresholds (totally heuristic for now)\n        // Variance is between 0 (perfectly aligned) and 1 (isotropic)\n        // Using degrees standard deviation might be easier to reason about?\n        // Let's use simple variance 0-1.\n\n        if (variance < 0.01) {\n            return { action: 'STRAIGHT', confidence: 1 - variance };\n        } else if (variance > 0.1) {\n            return { action: 'TURN', confidence: variance };\n        } else {\n            return { action: 'STRAIGHT', confidence: 0.5 };\n        }\n    }\n\n    private calculateCircularVariance(angles: number[]): number {\n        // R = sqrt( (sum cos)^2 + (sum sin)^2 )\n        // Mean Resultant Length R_bar = R / N\n        // Variance = 1 - R_bar\n\n        // Convert to radians\n        const rads = angles.map(d => d * Math.PI / 180);\n\n        let sumCos = 0;\n        let sumSin = 0;\n\n        for (const r of rads) {\n            sumCos += Math.cos(r);\n            sumSin += Math.sin(r);\n        }\n\n        const R = Math.sqrt(sumCos * sumCos + sumSin * sumSin);\n        const R_bar = R / angles.length;\n\n        return 1 - R_bar;\n    }\n}\n","import type { LiveMotionInput, LiveMotionPolicy } from '../types.js';\nimport type { MotionEstimate, MotionPose, NetworkBuffer, PhysicsModel, ConfidenceModel, IntentModel } from './types.js';\nimport { SimpleNetworkBuffer } from './NetworkBuffer.js';\nimport { KinematicPhysicsModel } from './PhysicsModel.js';\nimport { TimeBasedConfidenceModel } from './ConfidenceModel.js';\nimport { VarianceIntentModel } from './IntentModel.js';\nimport { lerpAngle, lerpPosition } from '../../utils/geo.js';\n\nexport class StandardMotionEngine {\n    private buffer: NetworkBuffer;\n    private physics: PhysicsModel;\n    private confidence: ConfidenceModel;\n    private intent: IntentModel;\n\n    // Current best estimate\n    private currentPose: MotionPose = {\n        lat: 0,\n        lng: 0,\n        heading: 0,\n        speed: 0,\n        uncertaintyRadius: 0\n    };\n\n    private lastTickTime = 0;\n    private initialized = false;\n\n    constructor(policy?: Partial<LiveMotionPolicy>) {\n        this.buffer = new SimpleNetworkBuffer();\n        this.physics = new KinematicPhysicsModel();\n        this.confidence = new TimeBasedConfidenceModel(policy);\n        this.intent = new VarianceIntentModel();\n    }\n\n    input(packet: LiveMotionInput): void {\n        this.buffer.push(packet);\n\n        // If not initialized, take valid packet immediately to start\n        if (!this.initialized && packet.timestamp) {\n            this.processObservation(packet);\n            this.initialized = true;\n            this.lastTickTime = packet.timestamp; // Start clock at packet time? Or Date.now()?\n            // If we are simulating, we use packet time. If live, we use Date.now().\n            // For now, assume Real-Time operation.\n            this.lastTickTime = Date.now();\n        }\n    }\n\n    getEstimate(): MotionEstimate {\n        return {\n            pose: this.currentPose,\n            state: this.confidence.getState(),\n            intent: this.intent.getIntent(),\n            timestamp: this.lastTickTime // Virtual time\n        };\n    }\n\n    tick(now: number): void {\n        if (!this.initialized) return;\n\n        // 1. Process Message Queue\n        // In a real loop, we might process multiple packets if we fell behind.\n        // For simple live logic, we usually empty the buffer of everything \"due\".\n        let packet = this.buffer.pop();\n        while (packet) {\n            this.processObservation(packet);\n            packet = this.buffer.pop();\n        }\n\n        // 2. Calculate dt\n        // We use system clock for dt in live mode.\n        const dt = (now - this.lastTickTime) / 1000;\n        this.lastTickTime = now;\n\n        if (dt <= 0) return;\n\n        // 3. Decay Confidence\n        this.confidence.decay(dt);\n        const state = this.confidence.getState();\n\n        // 4. Physics Step\n        if (state === 'FROZEN') {\n            // Stop physics integration\n            this.currentPose.speed = 0;\n        } else {\n            // COASTING or REAL or PREDICTED\n            // Integrate\n            this.currentPose = this.physics.step(this.currentPose, dt);\n        }\n    }\n\n    private processObservation(packet: LiveMotionInput): void {\n        // Update physics state (snap or blend?)\n        // Ideally we blend, but for Step 1 of Stage 3, let's snap physics parameters to reality\n        // and blend position.\n\n        this.physics.update(packet);\n        this.confidence.update(packet);\n        this.intent.update(packet);\n\n        // Correction Step (Kalman-lite)\n        // Lerp current position towards observation\n        const observedLat = packet.lat;\n        const observedLng = packet.lng;\n\n        // Simple trust-weighted blend\n        // If we are fully confident, we trust observation high\n        // FIX: If not initialized (first fix), snap 100%. Otherwise blend.\n        const blendFactor = this.initialized ? 0.5 : 1.0;\n\n        const corrected = lerpPosition(\n            { lat: this.currentPose.lat, lon: this.currentPose.lng },\n            { lat: observedLat, lon: observedLng },\n            blendFactor\n        );\n\n        this.currentPose.lat = corrected.lat;\n        this.currentPose.lng = corrected.lon;\n\n        // Update heading if provided, otherwise trust physics integration or blend\n        if (packet.bearing !== undefined) {\n            const angleBlend = this.initialized ? 0.5 : 1.0;\n            this.currentPose.heading = lerpAngle(this.currentPose.heading, packet.bearing, angleBlend);\n        }\n\n        // Reset uncertainty on fresh observation (to some sensor noise baseline)\n        this.currentPose.uncertaintyRadius = 5; // 5 meters base error\n    }\n}\n","import type { LiveMotionInput, LiveMotionPolicy } from '../types.js';\nimport type { MarkerAdapter } from '../interfaces/MarkerAdapter.js';\nimport { StandardMotionEngine } from '../motion/MotionEngine.js'; // Class import is fine\nimport type { MotionState } from '../motion/types.js';\n\nexport class LiveMotionController {\n    // Map vehicle ID to its own Motion Engine brain\n    private engines = new Map<string | number, StandardMotionEngine>();\n\n    private liveAnimationFrameId: number | null = null;\n    private lastLiveFrameTime = 0;\n    private policy: LiveMotionPolicy;\n\n    constructor(\n        private markerAdapter: MarkerAdapter,\n        policy?: Partial<LiveMotionPolicy>\n    ) {\n        this.policy = {\n            fullConfidenceMs: 5000,\n            decayMs: 10000,\n            maxStaleMs: 15 * 60 * 1000,\n            ...policy\n        };\n    }\n\n    /**\n     * Updates the state of a vehicle/unit using the Motion Engine.\n     */\n    update(input: LiveMotionInput): void {\n        const { id } = input;\n\n        let engine = this.engines.get(id);\n        if (!engine) {\n            engine = new StandardMotionEngine(this.policy);\n            this.engines.set(id, engine);\n        }\n\n        // Feed the brain\n        engine.input(input);\n    }\n\n    remove(id: string | number): void {\n        this.engines.delete(id);\n    }\n\n    start(): void {\n        if (typeof window === 'undefined') return;\n        if (this.liveAnimationFrameId !== null) return;\n\n        const animate = (time: number) => {\n            if (!this.lastLiveFrameTime) this.lastLiveFrameTime = time;\n            // time is high precision monotonic, but our engines use Date.now() for wall clock sync\n            // Let's stick to Date.now() for the engine tick to match the real-world timestamping of packets.\n            const now = Date.now();\n\n            this.engines.forEach((engine, id) => {\n                // 1. Tick the engine (Integrate physics, decay confidence)\n                engine.tick(now);\n\n                // 2. Get the confident estimate\n                const estimate = engine.getEstimate();\n\n                // 3. Render\n                this.markerAdapter.setMarkerPosition(id, estimate.pose.lat, estimate.pose.lng);\n                this.markerAdapter.setMarkerRotation?.(id, estimate.pose.heading);\n\n                // Optional: Visualize state (e.g. opacity for coasting/frozen)\n                // This would require extending MarkerAdapter to support opacity/state\n                // For now, we implement \"honesty\" by just rendering where it thinks it is.\n                this.handleStateVisuals(id, estimate.state);\n            });\n\n            this.lastLiveFrameTime = time;\n            this.liveAnimationFrameId = requestAnimationFrame(animate);\n        };\n\n        this.liveAnimationFrameId = requestAnimationFrame(animate);\n    }\n\n    private handleStateVisuals(id: string | number, state: MotionState): void {\n        // Placeholder for future UX hooks defined in the roadmap\n        // e.g. Ghost markers, opacity, etc.\n        // if (state === 'FROZEN') ...\n    }\n\n    stop(): void {\n        if (this.liveAnimationFrameId !== null) {\n            cancelAnimationFrame(this.liveAnimationFrameId);\n            this.liveAnimationFrameId = null;\n            this.lastLiveFrameTime = 0;\n        }\n    }\n\n    clear(): void {\n        this.engines.clear();\n    }\n}\n","/// <reference types=\"@types/google.maps\" />\nimport { haversineDistance, computeBearing } from '../../utils/geo.js';\n\n\ntype GoogleNamespace = typeof google;\n\n// Simple navigation arrow pointing North (0,-6)\nconst DEFAULT_REPLAY_SVG_PATH = 'M 0,-6 L 4,6 L 0,4 L -4,6 Z';\n\nfunction buildSvgSymbol(bearing: number): google.maps.Symbol {\n    return {\n        path: DEFAULT_REPLAY_SVG_PATH,\n        rotation: bearing,\n        scale: 3,\n        fillOpacity: 1,\n        strokeWeight: 1,\n        strokeColor: '#000000',\n        fillColor: '#FFFFFF', // White arrow\n        anchor: new google.maps.Point(0, 0) // Centered\n    };\n}\n\nexport class TripReplayController {\n    private tripMarkers: google.maps.Marker[] = [];\n    private currentPolyline: google.maps.Polyline | null = null;\n    private vehicleMarker: google.maps.Marker | null = null;\n\n    // Data state\n    private coordinates: any[] = [];\n    private baseDuration = 0;\n\n    // Animation state\n    private animationFrameId: number | null = null;\n    private isPaused = false;\n    private animationStartTime = 0;\n    private pausedTime = 0;\n    private totalAnimationTime = 0;\n    private animationPath: any[] = [];\n    private onFinish: (() => void) | null = null;\n    private lastPauseTime = 0;\n\n    constructor(\n        private map: google.maps.Map,\n        private google: GoogleNamespace\n    ) { }\n\n    load(coordinates: any[]): void {\n        this.stop();\n        this.coordinates = coordinates || [];\n        this.drawPolyline(this.coordinates);\n\n        // Calculate base duration from timestamps if available\n        if (this.coordinates.length >= 2) {\n            const first = this.coordinates[0];\n            const last = this.coordinates[this.coordinates.length - 1];\n            if (first.ts && last.ts) {\n                this.baseDuration = Number(last.ts) - Number(first.ts);\n            } else if (first.timestamp && last.timestamp) { // Support alternative timestamp key\n                this.baseDuration = new Date(last.timestamp).getTime() - new Date(first.timestamp).getTime();\n            } else {\n                this.baseDuration = 10000; // Default 10s if no timestamps\n            }\n        }\n    }\n\n    drawPolyline(coordinates: any[]): void {\n        this.clearPolyline();\n\n        if (!coordinates || coordinates.length === 0) return;\n\n        const path: google.maps.LatLngLiteral[] = [];\n        const bounds = new this.google.maps.LatLngBounds();\n\n        coordinates.forEach(coord => {\n            const lat = Number(coord.lat);\n            const lng = Number(coord.lng || coord.lon);\n            if (!isNaN(lat) && !isNaN(lng)) {\n                const pos = { lat, lng };\n                path.push(pos);\n                bounds.extend(pos);\n\n                // Markers for alerts/ignition\n                if (coord.itemType === 'alert') {\n                    let iconUrl = null;\n                    if (coord.type === 'ignition_on') iconUrl = '/marker/marker-power-on.png';\n                    else if (coord.type === 'ignition_off') iconUrl = '/marker/marker-power-off.png';\n\n                    if (iconUrl) {\n                        const marker = new this.google.maps.Marker({\n                            position: pos,\n                            map: this.map,\n                            icon: {\n                                url: iconUrl,\n                                scaledSize: new this.google.maps.Size(32, 32),\n                                anchor: new this.google.maps.Point(16, 16)\n                            },\n                            title: coord.type\n                        });\n                        this.tripMarkers.push(marker);\n                    }\n                }\n            }\n        });\n\n        this.currentPolyline = new this.google.maps.Polyline({\n            path,\n            geodesic: true,\n            strokeColor: '#00FFFF',\n            strokeOpacity: 1.0,\n            strokeWeight: 4,\n            map: this.map\n        });\n\n        this.map.fitBounds(bounds);\n    }\n\n    play(options: { speed?: number, duration?: number } = {}, onFinish?: () => void): void {\n        if (!this.coordinates || this.coordinates.length < 2) return;\n\n        this.stop();\n\n        this.onFinish = onFinish || null;\n\n        // Determine total duration\n        let duration = options.duration;\n        if (!duration && options.speed) {\n            duration = this.baseDuration / options.speed;\n        }\n        if (!duration) duration = 10000; // Fallback\n\n        // Map and filter while preserving original properties for bearing/course/heading\n        const rawPath = this.coordinates.map(c => {\n            let bearing = undefined;\n            if (c.heading !== undefined) bearing = Number(c.heading);\n            else if (c.course !== undefined) bearing = Number(c.course);\n            else if (c.bearing !== undefined) bearing = Number(c.bearing);\n\n            return {\n                lat: Number(c.lat),\n                lng: Number(c.lng || c.lon),\n                bearing\n            };\n        }).filter(c => !isNaN(c.lat) && !isNaN(c.lng));\n\n        this.animationPath = this.prepareAnimationPath(rawPath, duration);\n        this.animationStartTime = performance.now();\n        this.pausedTime = 0;\n        this.isPaused = false;\n\n        // Create vehicle marker reuse logic\n        if (!this.vehicleMarker) {\n            this.vehicleMarker = new this.google.maps.Marker({\n                map: this.map,\n                zIndex: 1000,\n                icon: buildSvgSymbol(0)\n            });\n        } else {\n            this.vehicleMarker.setMap(this.map);\n        }\n\n        if (this.animationPath.length > 0) {\n            const firstSeg = this.animationPath[0];\n            const start = firstSeg.type === 'move' ? firstSeg.start : firstSeg.position;\n            this.vehicleMarker.setPosition(start);\n            // Initialize rotation if available\n            if (firstSeg.type === 'move' && firstSeg.bearing !== undefined) {\n                this.vehicleMarker.setIcon(buildSvgSymbol(firstSeg.bearing));\n            }\n        }\n\n        this.startAnimationLoop();\n    }\n\n    private startAnimationLoop(): void {\n        const animate = (time: number) => {\n            if (this.isPaused) {\n                return;\n            }\n\n            const elapsed = time - this.animationStartTime - this.pausedTime;\n            if (elapsed >= this.totalAnimationTime) {\n                const last = this.animationPath[this.animationPath.length - 1];\n                const end = last.type === 'move' ? last.end : last.position;\n                if (this.vehicleMarker) {\n                    this.vehicleMarker.setPosition(end);\n                    if (last.type === 'move' && last.bearing !== undefined) {\n                        this.vehicleMarker.setIcon(buildSvgSymbol(last.bearing));\n                    }\n                }\n                this.isPaused = true;\n                this.onFinish?.();\n                return;\n            }\n\n            const segment = this.animationPath.find(s => elapsed >= s.startTime && elapsed < s.endTime);\n            if (segment && this.vehicleMarker) {\n                if (segment.type === 'stop') {\n                    this.vehicleMarker.setPosition(segment.position);\n                } else if (segment.type === 'move') {\n                    const segElapsed = elapsed - segment.startTime;\n                    const progress = segElapsed / segment.duration;\n                    const lat = segment.start.lat + (segment.end.lat - segment.start.lat) * progress;\n                    const lng = segment.start.lng + (segment.end.lng - segment.start.lng) * progress;\n                    this.vehicleMarker.setPosition({ lat, lng });\n\n                    // Update rotation\n                    if (segment.bearing !== undefined) {\n                        this.vehicleMarker.setIcon(buildSvgSymbol(segment.bearing));\n                    }\n                }\n            }\n            this.animationFrameId = requestAnimationFrame(animate);\n        };\n        this.animationFrameId = requestAnimationFrame(animate);\n    }\n\n    stop(): void {\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        if (this.vehicleMarker) {\n            this.vehicleMarker.setMap(null);\n        }\n        this.isPaused = false;\n        this.pausedTime = 0;\n    }\n\n    pause(): void {\n        if (this.isPaused || !this.animationFrameId) return;\n        this.isPaused = true;\n        this.lastPauseTime = performance.now();\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n\n    resume(): void {\n        if (!this.isPaused) return;\n        this.isPaused = false;\n        // Calculate how long we were paused\n        const now = performance.now();\n        const pauseDuration = now - this.lastPauseTime;\n        this.pausedTime += pauseDuration;\n\n        this.startAnimationLoop();\n    }\n\n    clearPolyline(): void {\n        if (this.currentPolyline) {\n            this.currentPolyline.setMap(null);\n            this.currentPolyline = null;\n        }\n        this.tripMarkers.forEach(m => m.setMap(null));\n        this.tripMarkers = [];\n        this.stop();\n    }\n\n    private prepareAnimationPath(rawPath: any[], totalDuration: number) {\n        const segments: any[] = [];\n        const STOP_THRESHOLD = 5;\n        const STOP_PAUSE_DURATION = 400;\n        let currentStop: any = null;\n\n        for (let i = 0; i < rawPath.length - 1; i++) {\n            const p1 = rawPath[i];\n            const p2 = rawPath[i + 1];\n            const dist = haversineDistance(p1, p2);\n\n            let bearing = 0;\n            // Prioritize explicit bearing/heading from p1\n            if (p1.bearing !== undefined) {\n                bearing = p1.bearing;\n            } else {\n                // Else calculate from movement\n                bearing = computeBearing(p1.lat, p1.lng, p2.lat, p2.lng);\n            }\n\n            if (dist < STOP_THRESHOLD) {\n                if (!currentStop) {\n                    currentStop = { type: 'stop', position: p1, duration: STOP_PAUSE_DURATION, bearing };\n                    segments.push(currentStop);\n                }\n            } else {\n                currentStop = null;\n                segments.push({\n                    type: 'move',\n                    start: p1,\n                    end: p2,\n                    distance: dist,\n                    duration: 0,\n                    bearing\n                });\n            }\n        }\n\n        const totalMoveDist = segments.filter(s => s.type === 'move').reduce((acc, s) => acc + s.distance, 0);\n        const totalStopDur = segments.filter(s => s.type === 'stop').reduce((acc, s) => acc + s.duration, 0);\n        const availableMoveTime = Math.max(1000, totalDuration - totalStopDur);\n\n        segments.forEach(s => {\n            if (s.type === 'move') {\n                s.duration = (s.distance / totalMoveDist) * availableMoveTime;\n            }\n        });\n\n        let accumulated = 0;\n        segments.forEach(s => {\n            s.startTime = accumulated;\n            accumulated += s.duration;\n            s.endTime = accumulated;\n        });\n\n        this.totalAnimationTime = accumulated;\n        return segments;\n    }\n}\n"],"mappings":"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","names":["google"]}