{"version":3,"sources":["../src/index.ts","../src/engine/MapEngine.ts","../src/providers/google/GoogleMapEngine.ts","../src/utils/geo.ts"],"sourcesContent":["export type {\n    VehicleLike,\n    ThemeName,\n    IconConfig,\n    IconResolver,\n    InfoWindowRenderer,\n    MapEngineOptions\n} from './engine/types.js';\n\nexport { MapEngine } from './engine/MapEngine.js';\nexport { GoogleMapEngine } from './providers/google/GoogleMapEngine.js';\n\nexport type {\n    GeoPoint,\n    LatLng\n} from './utils/geo.js';\n\nexport {\n    haversineDistance,\n    computeBearing,\n    extrapolatePosition,\n    lerpPosition\n} from './utils/geo.js';\n","import type { MapEngineOptions, ThemeName, VehicleLike } from './types.js';\n\n/**\n * Abstract base class for Map Engines (e.g., Google Maps, Leaflet, Mapbox).\n * Defines the contract for interacting with the map.\n */\nexport abstract class MapEngine {\n    protected options: MapEngineOptions;\n\n    constructor(options: MapEngineOptions) {\n        this.options = options;\n    }\n\n    /**\n     * Initializes and mounts the map to the specified DOM element.\n     * @param element The container ID or HTMLElement.\n     */\n    abstract mount(element: string | HTMLElement): Promise<any>;\n\n    /**\n     * Adds a marker for a vehicle.\n     */\n    abstract addVehicleMarker(vehicle: VehicleLike): void;\n\n    /**\n     * Updates an existing vehicle marker (position, icon, content).\n     */\n    abstract updateVehicleMarker(vehicle: VehicleLike): void;\n\n    /**\n     * Removes a vehicle marker by ID.\n     */\n    abstract removeMarker(id: string | number): void;\n\n    /**\n     * Removes all markers from the map.\n     */\n    abstract clearAllMarkers(): void;\n\n    /**\n     * Centers the map to fit the given vehicles.\n     */\n    abstract centerOnVehicles(vehicles: VehicleLike[]): void;\n\n    /**\n     * Centers the map on a specific vehicle/location.\n     */\n    abstract setCenter(lat: number, lng: number): void;\n\n    /**\n     * Sets the zoom level.\n     */\n    abstract setZoom(zoom: number): void;\n\n    /**\n     * Draws a polyline for a trip/route.\n     */\n    abstract drawTripPolyline(coordinates: any[]): void;\n\n    /**\n     * Clears the current trip polyline.\n     */\n    abstract clearTripPolyline(): void;\n\n    /**\n     * Animates a vehicle along a path.\n     */\n    abstract animateTrip(coordinates: any[], totalDuration?: number, onFinish?: () => void): void;\n\n    /**\n     * Stops any active trip animation.\n     */\n    abstract stopTripAnimation(): void;\n\n    /**\n     * Updates the map theme.\n     */\n    setTheme(theme: ThemeName): void {\n        this.options.theme = theme;\n        this.onThemeChange(theme);\n    }\n\n    /**\n     * Internal method to handle theme changes in the specific implementation.\n     */\n    protected abstract onThemeChange(theme: ThemeName): void;\n\n    /**\n     * Cleans up resources.\n     */\n    abstract dispose(): void;\n}\n","/// <reference types=\"@types/google.maps\" />\nimport { setOptions, importLibrary } from '@googlemaps/js-api-loader';\nimport { MapEngine } from '../../engine/MapEngine.js';\nimport type { MapEngineOptions, ThemeName, VehicleLike, IconConfig } from '../../engine/types.js';\nimport { haversineDistance, computeBearing, extrapolatePosition, lerpPosition } from '../../utils/geo.js';\nimport type { LatLng } from '../../utils/geo.js';\n\ninterface LiveUnitState {\n    lastFix: { lat: number; lon: number; ts: number };\n    prevFix: { lat: number; lon: number; ts: number } | null;\n    speed: number; // m/s\n    bearing: number;\n    virtualPosition: { lat: number; lon: number };\n    lastUpdateTs: number;\n    isStopped: boolean;\n}\n\nexport class GoogleMapEngine extends MapEngine {\n    private map: google.maps.Map | null = null;\n    private google: typeof google | null = null;\n    private markers = new Map<string | number, { marker: google.maps.Marker; infoWindow: google.maps.InfoWindow }>();\n    private tripMarkers: google.maps.Marker[] = [];\n    private currentPolyline: google.maps.Polyline | null = null;\n\n    // Live Animation\n    private liveVehicles = new Map<string | number, LiveUnitState>();\n    private liveAnimationFrameId: number | null = null;\n    private lastLiveFrameTime = 0;\n\n    // Trip Animation\n    private vehicleMarker: google.maps.Marker | null = null;\n    private animationFrameId: number | null = null;\n    private isPaused = false;\n    private animationStartTime = 0;\n    private pausedTime = 0;\n    private totalAnimationTime = 0;\n    private animationPath: any[] = [];\n    private onFinish: (() => void) | null = null;\n\n    constructor(options: MapEngineOptions) {\n        super(options);\n        // Start live animation loop immediately, it will be idle until markers are added\n        this.startLiveAnimationLoop();\n    }\n\n    async mount(element: string | HTMLElement): Promise<google.maps.Map> {\n        const apiKey = this.options.apiKey || (import.meta as any).env.VITE_GOOGLE_MAPS_API_KEY;\n        if (!apiKey) {\n            throw new Error('Google Maps API Key is required');\n        }\n\n        setOptions({\n            key: apiKey,\n            v: 'weekly',\n            libraries: ['places']\n        });\n\n        await importLibrary('maps');\n        await importLibrary('marker');\n\n        this.google = google;\n\n        const initialTheme: ThemeName = this.options.theme || 'modern';\n        const styles = this.getStylesForTheme(initialTheme);\n\n        // Default options + overrides\n        const backgroundColor = this.getBackgroundColorForTheme(initialTheme);\n        const mapOptions: google.maps.MapOptions = {\n            backgroundColor: this.options.backgroundColor || backgroundColor,\n            center: this.options.center || { lat: 19.4326, lng: -99.1332 },\n            zoom: this.options.zoom || 13,\n            fullscreenControl: true,\n            streetViewControl: false,\n            mapTypeControl: false,\n            zoomControl: true,\n            styles: (styles as any) || undefined,\n            disableDefaultUI: true,\n            ...this.options.mapOptions // allow overriding arbitrary google map options\n        };\n\n        const el = typeof element === 'string' ? document.getElementById(element) : element;\n        if (!el) throw new Error('Map container element not found');\n\n        this.map = new this.google!.maps.Map(el as HTMLElement, mapOptions);\n\n        return this.map;\n    }\n\n    private getBackgroundColorForTheme(theme: ThemeName): string {\n        switch (theme) {\n            case 'modern': return '#0b1524';\n            case 'dark': return '#0f1115';\n            case 'light': default: return '#ffffff';\n        }\n    }\n\n    private getStylesForTheme(theme: ThemeName): google.maps.MapTypeStyle[] | null {\n        if (this.options.styles && this.options.styles[theme]) {\n            return this.options.styles[theme];\n        }\n        return null;\n    }\n\n    protected onThemeChange(theme: ThemeName): void {\n        console.log('[GoogleMapEngine] onThemeChange called with:', theme);\n        if (this.map) {\n            const styles = this.getStylesForTheme(theme);\n            const backgroundColor = this.getBackgroundColorForTheme(theme);\n            console.log('[GoogleMapEngine] Applying styles count:', styles?.length, 'bg:', backgroundColor);\n            this.map.setOptions({ styles, backgroundColor });\n        } else {\n            console.warn('[GoogleMapEngine] Map not initialized, skipping theme update');\n        }\n    }\n\n    addVehicleMarker(vehicle: VehicleLike): void {\n        if (!this.map || !this.google) return;\n\n        const lat = Number(vehicle.lat || vehicle.latitude);\n        const lng = Number(vehicle.lng || vehicle.longitude);\n        const id = vehicle.id || vehicle.device_id || vehicle.deviceId;\n\n        if (isNaN(lat) || isNaN(lng) || !id) {\n            console.warn('Invalid coords or ID for vehicle', vehicle);\n            return;\n        }\n\n        const position = { lat, lng };\n\n        // Use IconResolver\n        let iconConfig: IconConfig = { url: '' };\n        if (this.options.iconResolver) {\n            iconConfig = this.options.iconResolver(vehicle);\n        }\n\n        const markerOptions: google.maps.MarkerOptions = {\n            position,\n            map: this.map,\n            title: String(vehicle.device_id || id),\n        };\n\n        if (iconConfig.url) {\n            markerOptions.icon = {\n                url: iconConfig.url,\n                scaledSize: iconConfig.size ? new this.google!.maps.Size(iconConfig.size[0], iconConfig.size[1]) : null,\n                anchor: iconConfig.anchor ? new this.google!.maps.Point(iconConfig.anchor[0], iconConfig.anchor[1]) : null\n            };\n        }\n\n        const marker = new this.google.maps.Marker(markerOptions);\n\n        // Info Window\n        let content = '';\n        if (this.options.infoWindowRenderer) {\n            content = this.options.infoWindowRenderer(vehicle);\n        }\n        const infoWindow = new this.google.maps.InfoWindow({ content });\n\n        marker.addListener('click', () => {\n            infoWindow.open(this.map, marker);\n        });\n\n        this.markers.set(id, { marker, infoWindow });\n        this.initLiveState(id, vehicle);\n    }\n\n    updateVehicleMarker(vehicle: VehicleLike): void {\n        const id = vehicle.id || vehicle.device_id || vehicle.deviceId;\n        const existing = this.markers.get(id);\n\n        if (!existing) {\n            this.addVehicleMarker(vehicle);\n            return;\n        }\n\n        const lat = Number(vehicle.lat || vehicle.latitude);\n        const lng = Number(vehicle.lng || vehicle.longitude);\n\n        if (!isNaN(lat) && !isNaN(lng)) {\n            // Update Info Window content\n            if (this.options.infoWindowRenderer) {\n                existing.infoWindow.setContent(this.options.infoWindowRenderer(vehicle));\n            }\n\n            // Update Icon\n            if (this.options.iconResolver) {\n                const iconConfig = this.options.iconResolver(vehicle);\n                if (iconConfig.url) {\n                    existing.marker.setIcon({\n                        url: iconConfig.url,\n                        scaledSize: iconConfig.size ? new this.google!.maps.Size(iconConfig.size[0], iconConfig.size[1]) : null,\n                        anchor: iconConfig.anchor ? new this.google!.maps.Point(iconConfig.anchor[0], iconConfig.anchor[1]) : null\n                    });\n                }\n            }\n\n            // Update Live State (Dead Reckoning)\n            this.updateLiveState(id, vehicle, lat, lng);\n        }\n    }\n\n    removeMarker(id: string | number): void {\n        const data = this.markers.get(id);\n        if (data) {\n            data.marker.setMap(null);\n            this.markers.delete(id);\n        }\n        this.liveVehicles.delete(id);\n    }\n\n    clearAllMarkers(): void {\n        this.markers.forEach(data => data.marker.setMap(null));\n        this.markers.clear();\n        this.liveVehicles.clear();\n    }\n\n    // ==========================================\n    // LIVE ANIMATION\n    // ==========================================\n\n    private initLiveState(id: string | number, vehicle: VehicleLike) {\n        const lat = Number(vehicle.lat || vehicle.latitude);\n        const lng = Number(vehicle.lng || vehicle.longitude);\n        const speedKmh = Number(vehicle.speed || 0);\n        const ts = Date.now();\n\n        this.liveVehicles.set(id, {\n            lastFix: { lat, lon: lng, ts },\n            prevFix: null,\n            speed: (speedKmh * 1000) / 3600, // m/s\n            bearing: parseFloat(String(vehicle.course || 0)),\n            virtualPosition: { lat, lon: lng },\n            lastUpdateTs: performance.now(),\n            isStopped: this.isVehicleStopped(vehicle)\n        });\n    }\n\n    private updateLiveState(id: string | number, vehicle: VehicleLike, newLat: number, newLon: number) {\n        const state = this.liveVehicles.get(id);\n        if (!state) {\n            this.initLiveState(id, vehicle);\n            return;\n        }\n\n        const now = performance.now();\n        const speedKmh = Number(vehicle.speed || 0);\n\n        state.prevFix = { ...state.lastFix };\n        state.lastFix = { lat: newLat, lon: newLon, ts: now };\n\n        if (state.prevFix) {\n            const dist = haversineDistance(\n                { lat: state.prevFix.lat, lng: state.prevFix.lon },\n                { lat: newLat, lng: newLon }\n            );\n            if (dist > 2) {\n                state.bearing = computeBearing(state.prevFix.lat, state.prevFix.lon, newLat, newLon);\n            } else if (vehicle.course) {\n                state.bearing = Number(vehicle.course);\n            }\n        }\n\n        state.speed = (speedKmh * 1000) / 3600;\n        state.isStopped = this.isVehicleStopped(vehicle);\n\n        // Snap if too far\n        const distVirtual = haversineDistance(\n            { lat: state.virtualPosition.lat, lng: state.virtualPosition.lon },\n            { lat: newLat, lng: newLon }\n        );\n\n        if (distVirtual > 500) {\n            state.virtualPosition = { lat: newLat, lon: newLon };\n        }\n    }\n\n    private isVehicleStopped(vehicle: VehicleLike): boolean {\n        const speed = Number(vehicle.speed || 0);\n        if (vehicle.msg_class === 'Alert') {\n            if (String(vehicle.alert) === 'Turn Off') return true;\n            if (String(vehicle.alert) === 'Turn On') return false;\n        }\n        if (String(vehicle.msg_class).toLowerCase() === 'status') {\n            const status = String(vehicle.engine_status as any);\n            if (status === 'OFF' || status === 'off' || status === 'false' || status === '0') return true;\n            if (status === 'ON' || status === 'on' || status === 'true' || status === '1') return false;\n        }\n        return speed < 1;\n    }\n\n    private startLiveAnimationLoop() {\n        if (typeof window === 'undefined') return;\n\n        const animate = (time: number) => {\n            if (!this.lastLiveFrameTime) this.lastLiveFrameTime = time;\n            const delta = time - this.lastLiveFrameTime;\n            this.lastLiveFrameTime = time;\n\n            const dt = Math.min(delta, 100) / 1000; // cap 100ms\n\n            this.liveVehicles.forEach((state, id) => {\n                const markerData = this.markers.get(id);\n                if (!markerData) return;\n\n                if (state.isStopped) {\n                    state.virtualPosition = lerpPosition(\n                        state.virtualPosition,\n                        { lat: state.lastFix.lat, lon: state.lastFix.lon },\n                        0.1\n                    );\n                } else {\n                    const projected = extrapolatePosition(\n                        state.virtualPosition.lat,\n                        state.virtualPosition.lon,\n                        state.speed,\n                        state.bearing,\n                        dt\n                    );\n                    state.virtualPosition = lerpPosition(\n                        projected,\n                        { lat: state.lastFix.lat, lon: state.lastFix.lon },\n                        0.05\n                    );\n                }\n\n                if (this.google && markerData.marker) {\n                    const newPos = new this.google.maps.LatLng(state.virtualPosition.lat, state.virtualPosition.lon);\n                    markerData.marker.setPosition(newPos);\n                }\n            });\n\n            this.liveAnimationFrameId = requestAnimationFrame(animate);\n        };\n\n        this.liveAnimationFrameId = requestAnimationFrame(animate);\n    }\n\n    centerOnVehicles(vehicles: VehicleLike[]): void {\n        if (!this.map || !this.google || !vehicles.length) return;\n        const bounds = new this.google.maps.LatLngBounds();\n        let hasValid = false;\n        vehicles.forEach(v => {\n            const lat = Number(v.lat || v.latitude);\n            const lng = Number(v.lng || v.longitude);\n            if (!isNaN(lat) && !isNaN(lng)) {\n                bounds.extend({ lat, lng });\n                hasValid = true;\n            }\n        });\n        if (hasValid) {\n            this.map.fitBounds(bounds);\n        }\n    }\n\n    setCenter(lat: number, lng: number): void {\n        if (this.map) {\n            this.map.setCenter({ lat, lng });\n        }\n    }\n\n    setZoom(zoom: number): void {\n        if (this.map) {\n            this.map.setZoom(zoom);\n        }\n    }\n\n    // ==========================================\n    // TRIP POLYLINE & ANIMATION\n    // ==========================================\n\n    drawTripPolyline(coordinates: any[]): void {\n        if (!this.map || !this.google) return;\n        this.clearTripPolyline();\n\n        if (!coordinates || coordinates.length === 0) return;\n\n        const path: google.maps.LatLngLiteral[] = [];\n        const bounds = new this.google.maps.LatLngBounds();\n\n        coordinates.forEach(coord => {\n            const lat = Number(coord.lat);\n            const lng = Number(coord.lng || coord.lon);\n            if (!isNaN(lat) && !isNaN(lng)) {\n                const pos = { lat, lng };\n                path.push(pos);\n                bounds.extend(pos);\n\n                // Markers for alerts/ignition\n                if (coord.itemType === 'alert') {\n                    let iconUrl = null;\n                    if (coord.type === 'ignition_on') iconUrl = '/marker/marker-power-on.png';\n                    else if (coord.type === 'ignition_off') iconUrl = '/marker/marker-power-off.png';\n\n                    if (iconUrl) {\n                        const marker = new this.google!.maps.Marker({\n                            position: pos,\n                            map: this.map,\n                            icon: {\n                                url: iconUrl,\n                                scaledSize: new this.google!.maps.Size(32, 32),\n                                anchor: new this.google!.maps.Point(16, 16)\n                            },\n                            title: coord.type\n                        });\n                        this.tripMarkers.push(marker);\n                    }\n                }\n            }\n        });\n\n        this.currentPolyline = new this.google.maps.Polyline({\n            path,\n            geodesic: true,\n            strokeColor: '#00FFFF',\n            strokeOpacity: 1.0,\n            strokeWeight: 4,\n            map: this.map\n        });\n\n        this.map.fitBounds(bounds);\n    }\n\n    clearTripPolyline(): void {\n        if (this.currentPolyline) {\n            this.currentPolyline.setMap(null);\n            this.currentPolyline = null;\n        }\n        this.tripMarkers.forEach(m => m.setMap(null));\n        this.tripMarkers = [];\n        this.stopTripAnimation();\n    }\n\n    stopTripAnimation(): void {\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        if (this.vehicleMarker) {\n            this.vehicleMarker.setMap(null);\n        }\n        this.isPaused = false;\n    }\n\n    animateTrip(coordinates: any[], totalDuration = 10000, onFinish?: () => void): void {\n        if (!this.map || !this.google || !coordinates || coordinates.length < 2) return;\n        this.stopTripAnimation();\n        this.onFinish = onFinish || null;\n\n        const rawPath = coordinates.map(c => ({\n            lat: Number(c.lat),\n            lng: Number(c.lng || c.lon)\n        })).filter(c => !isNaN(c.lat) && !isNaN(c.lng));\n\n        this.animationPath = this.prepareAnimationPath(rawPath, totalDuration);\n        this.animationStartTime = performance.now();\n        this.pausedTime = 0;\n        this.isPaused = false;\n\n        // Create vehicle marker reuse logic\n        if (!this.vehicleMarker) {\n            this.vehicleMarker = new this.google.maps.Marker({\n                map: this.map,\n                icon: {\n                    // If we want a separate icon for trip, or use generic. \n                    // The original code used specific generic car. \n                    // We should probably allow customization or fallback.\n                    url: 'https://cdn-icons-png.flaticon.com/512/3202/3202926.png', // Temporary fallback or use options?\n                    // Actually the original code imported unitIcons and used generic one.\n                    // Assuming we can rely on some default web URL or updated logic later.\n                    // For now I'll use a placeholder or check if I can use iconResolver?\n                    // But iconResolver resolves for a \"VehicleLike\". Here we are animating a trip.\n                    // I will assume a default marker or reuse logic.\n                    // Original: unitIcons['vehicle-car-sedan']\n                    scaledSize: new this.google.maps.Size(40, 40),\n                    anchor: new this.google.maps.Point(20, 20)\n                },\n                zIndex: 1000\n            });\n        } else {\n            this.vehicleMarker.setMap(this.map);\n        }\n\n        // Attempt to set correct icon if possible, but trip coords might not have full vehicle info.\n        // We will stick to the created marker.\n\n        if (this.animationPath.length > 0) {\n            const start = this.animationPath[0].type === 'move' ? this.animationPath[0].start : this.animationPath[0].position;\n            this.vehicleMarker.setPosition(start);\n        }\n\n        const animate = (time: number) => {\n            if (this.isPaused) {\n                this.animationFrameId = requestAnimationFrame(animate);\n                return;\n            }\n\n            const elapsed = time - this.animationStartTime - this.pausedTime;\n            if (elapsed >= this.totalAnimationTime) {\n                const last = this.animationPath[this.animationPath.length - 1];\n                const end = last.type === 'move' ? last.end : last.position;\n                this.vehicleMarker?.setPosition(end);\n                this.isPaused = true;\n                this.onFinish?.();\n                return;\n            }\n\n            const segment = this.animationPath.find(s => elapsed >= s.startTime && elapsed < s.endTime);\n            if (segment && this.vehicleMarker) {\n                if (segment.type === 'stop') {\n                    this.vehicleMarker.setPosition(segment.position);\n                } else if (segment.type === 'move') {\n                    const segElapsed = elapsed - segment.startTime;\n                    const progress = segElapsed / segment.duration;\n                    const lat = segment.start.lat + (segment.end.lat - segment.start.lat) * progress;\n                    const lng = segment.start.lng + (segment.end.lng - segment.start.lng) * progress;\n                    this.vehicleMarker.setPosition({ lat, lng });\n                }\n            }\n            this.animationFrameId = requestAnimationFrame(animate);\n        };\n\n        this.animationFrameId = requestAnimationFrame(animate);\n    }\n\n    private prepareAnimationPath(rawPath: any[], totalDuration: number) {\n        const segments: any[] = [];\n        const STOP_THRESHOLD = 5;\n        const STOP_PAUSE_DURATION = 400;\n        let currentStop: any = null;\n\n        for (let i = 0; i < rawPath.length - 1; i++) {\n            const p1 = rawPath[i];\n            const p2 = rawPath[i + 1];\n            const dist = haversineDistance(p1, p2);\n\n            if (dist < STOP_THRESHOLD) {\n                if (!currentStop) {\n                    currentStop = { type: 'stop', position: p1, duration: STOP_PAUSE_DURATION };\n                    segments.push(currentStop);\n                }\n            } else {\n                currentStop = null;\n                segments.push({ type: 'move', start: p1, end: p2, distance: dist, duration: 0 });\n            }\n        }\n\n        const totalMoveDist = segments.filter(s => s.type === 'move').reduce((acc, s) => acc + s.distance, 0);\n        const totalStopDur = segments.filter(s => s.type === 'stop').reduce((acc, s) => acc + s.duration, 0);\n        const availableMoveTime = Math.max(1000, totalDuration - totalStopDur);\n\n        segments.forEach(s => {\n            if (s.type === 'move') {\n                s.duration = (s.distance / totalMoveDist) * availableMoveTime;\n            }\n        });\n\n        let accumulated = 0;\n        segments.forEach(s => {\n            s.startTime = accumulated;\n            accumulated += s.duration;\n            s.endTime = accumulated;\n        });\n\n        this.totalAnimationTime = accumulated;\n        return segments;\n    }\n\n    dispose(): void {\n        if (this.liveAnimationFrameId) cancelAnimationFrame(this.liveAnimationFrameId);\n        this.stopTripAnimation();\n        this.clearAllMarkers();\n        if (this.currentPolyline) this.currentPolyline.setMap(null);\n        this.map = null;\n    }\n}\n","export interface GeoPoint {\n    lat: number;\n    lng: number; // standardized to lng but supporting lon for input if needed\n}\n\nexport interface LatLng {\n    lat: number;\n    lng: number;\n}\n\n/**\n * Calculates the distance between two points in meters using the Haversine formula.\n */\nexport function haversineDistance(coords1: { lat: number; lng?: number; lon?: number }, coords2: { lat: number; lng?: number; lon?: number }): number {\n    const R = 6371e3; // metres\n    const lat1 = coords1.lat;\n    const lon1 = coords1.lng ?? coords1.lon ?? 0;\n    const lat2 = coords2.lat;\n    const lon2 = coords2.lng ?? coords2.lon ?? 0;\n\n    const φ1 = (lat1 * Math.PI) / 180; // φ, λ in radians\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δφ = ((lat2 - lat1) * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const a =\n        Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // in metres\n}\n\n/**\n * Computes the bearing (heading) from one point to another in degrees (0-360).\n */\nexport function computeBearing(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const φ1 = (lat1 * Math.PI) / 180;\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const y = Math.sin(Δλ) * Math.cos(φ2);\n    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n\n    return ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;\n}\n\n/**\n * Extrapolates a new position based on start point, speed, bearing and time delta.\n */\nexport function extrapolatePosition(lat: number, lon: number, speedMps: number, bearingDeg: number, deltaSeconds: number): { lat: number; lon: number } {\n    const R = 6378137;\n    const dist = speedMps * deltaSeconds;\n    const δ = dist / R;\n    const θ = (bearingDeg * Math.PI) / 180;\n\n    const φ1 = (lat * Math.PI) / 180;\n    const λ1 = (lon * Math.PI) / 180;\n\n    const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));\n\n    const λ2 =\n        λ1 +\n        Math.atan2(\n            Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),\n            Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2)\n        );\n\n    return {\n        lat: (φ2 * 180) / Math.PI,\n        lon: (λ2 * 180) / Math.PI\n    };\n}\n\n/**\n * Linearly interpolates between two positions.\n */\nexport function lerpPosition(pos1: { lat: number; lon: number }, pos2: { lat: number; lon: number }, t: number): { lat: number; lon: number } {\n    return {\n        lat: pos1.lat + (pos2.lat - pos1.lat) * t,\n        lon: pos1.lon + (pos2.lon - pos1.lon) * t\n    };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACMO,IAAe,YAAf,MAAyB;AAAA,EAClB;AAAA,EAEV,YAAY,SAA2B;AACnC,SAAK,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAkEA,SAAS,OAAwB;AAC7B,SAAK,QAAQ,QAAQ;AACrB,SAAK,cAAc,KAAK;AAAA,EAC5B;AAWJ;;;AC1FA,2BAA0C;;;ACYnC,SAAS,kBAAkB,SAAsD,SAA8D;AAClJ,QAAM,IAAI;AACV,QAAM,OAAO,QAAQ;AACrB,QAAM,OAAO,QAAQ,OAAO,QAAQ,OAAO;AAC3C,QAAM,OAAO,QAAQ;AACrB,QAAM,OAAO,QAAQ,OAAO,QAAQ,OAAO;AAE3C,QAAM,UAAM,OAAO,KAAK,KAAM;AAC9B,QAAM,UAAM,OAAO,KAAK,KAAM;AAC9B,QAAM,gBAAO,OAAO,QAAQ,KAAK,KAAM;AACvC,QAAM,gBAAO,OAAO,QAAQ,KAAK,KAAM;AAEvC,QAAM,IACF,KAAK,IAAI,eAAK,CAAC,IAAI,KAAK,IAAI,eAAK,CAAC,IAClC,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,eAAK,CAAC,IAAI,KAAK,IAAI,eAAK,CAAC;AACpE,QAAM,IAAI,IAAI,KAAK,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC,CAAC;AAEvD,SAAO,IAAI;AACf;AAKO,SAAS,eAAe,MAAc,MAAc,MAAc,MAAsB;AAC3F,QAAM,UAAM,OAAO,KAAK,KAAM;AAC9B,QAAM,UAAM,OAAO,KAAK,KAAM;AAC9B,QAAM,gBAAO,OAAO,QAAQ,KAAK,KAAM;AAEvC,QAAM,IAAI,KAAK,IAAI,YAAE,IAAI,KAAK,IAAI,OAAE;AACpC,QAAM,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,YAAE;AAEjF,UAAS,KAAK,MAAM,GAAG,CAAC,IAAI,MAAO,KAAK,KAAK,OAAO;AACxD;AAKO,SAAS,oBAAoB,KAAa,KAAa,UAAkB,YAAoB,cAAoD;AACpJ,QAAM,IAAI;AACV,QAAM,OAAO,WAAW;AACxB,QAAM,SAAI,OAAO;AACjB,QAAM,SAAK,aAAa,KAAK,KAAM;AAEnC,QAAM,UAAM,MAAM,KAAK,KAAM;AAC7B,QAAM,UAAM,MAAM,KAAK,KAAM;AAE7B,QAAM,UAAK,KAAK,KAAK,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,MAAC,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,MAAC,IAAI,KAAK,IAAI,MAAC,CAAC;AAE1F,QAAM,UACF,UACA,KAAK;AAAA,IACD,KAAK,IAAI,MAAC,IAAI,KAAK,IAAI,MAAC,IAAI,KAAK,IAAI,OAAE;AAAA,IACvC,KAAK,IAAI,MAAC,IAAI,KAAK,IAAI,OAAE,IAAI,KAAK,IAAI,OAAE;AAAA,EAC5C;AAEJ,SAAO;AAAA,IACH,KAAM,UAAK,MAAO,KAAK;AAAA,IACvB,KAAM,UAAK,MAAO,KAAK;AAAA,EAC3B;AACJ;AAKO,SAAS,aAAa,MAAoC,MAAoC,GAAyC;AAC1I,SAAO;AAAA,IACH,KAAK,KAAK,OAAO,KAAK,MAAM,KAAK,OAAO;AAAA,IACxC,KAAK,KAAK,OAAO,KAAK,MAAM,KAAK,OAAO;AAAA,EAC5C;AACJ;;;ADlFA;AAiBO,IAAM,kBAAN,cAA8B,UAAU;AAAA,EACnC,MAA8B;AAAA,EAC9B,SAA+B;AAAA,EAC/B,UAAU,oBAAI,IAAyF;AAAA,EACvG,cAAoC,CAAC;AAAA,EACrC,kBAA+C;AAAA;AAAA,EAG/C,eAAe,oBAAI,IAAoC;AAAA,EACvD,uBAAsC;AAAA,EACtC,oBAAoB;AAAA;AAAA,EAGpB,gBAA2C;AAAA,EAC3C,mBAAkC;AAAA,EAClC,WAAW;AAAA,EACX,qBAAqB;AAAA,EACrB,aAAa;AAAA,EACb,qBAAqB;AAAA,EACrB,gBAAuB,CAAC;AAAA,EACxB,WAAgC;AAAA,EAExC,YAAY,SAA2B;AACnC,UAAM,OAAO;AAEb,SAAK,uBAAuB;AAAA,EAChC;AAAA,EAEA,MAAM,MAAM,SAAyD;AACjE,UAAM,SAAS,KAAK,QAAQ,UAAW,YAAoB,IAAI;AAC/D,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACrD;AAEA,yCAAW;AAAA,MACP,KAAK;AAAA,MACL,GAAG;AAAA,MACH,WAAW,CAAC,QAAQ;AAAA,IACxB,CAAC;AAED,cAAM,oCAAc,MAAM;AAC1B,cAAM,oCAAc,QAAQ;AAE5B,SAAK,SAAS;AAEd,UAAM,eAA0B,KAAK,QAAQ,SAAS;AACtD,UAAM,SAAS,KAAK,kBAAkB,YAAY;AAGlD,UAAM,kBAAkB,KAAK,2BAA2B,YAAY;AACpE,UAAM,aAAqC;AAAA,MACvC,iBAAiB,KAAK,QAAQ,mBAAmB;AAAA,MACjD,QAAQ,KAAK,QAAQ,UAAU,EAAE,KAAK,SAAS,KAAK,SAAS;AAAA,MAC7D,MAAM,KAAK,QAAQ,QAAQ;AAAA,MAC3B,mBAAmB;AAAA,MACnB,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,aAAa;AAAA,MACb,QAAS,UAAkB;AAAA,MAC3B,kBAAkB;AAAA,MAClB,GAAG,KAAK,QAAQ;AAAA;AAAA,IACpB;AAEA,UAAM,KAAK,OAAO,YAAY,WAAW,SAAS,eAAe,OAAO,IAAI;AAC5E,QAAI,CAAC,GAAI,OAAM,IAAI,MAAM,iCAAiC;AAE1D,SAAK,MAAM,IAAI,KAAK,OAAQ,KAAK,IAAI,IAAmB,UAAU;AAElE,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,2BAA2B,OAA0B;AACzD,YAAQ,OAAO;AAAA,MACX,KAAK;AAAU,eAAO;AAAA,MACtB,KAAK;AAAQ,eAAO;AAAA,MACpB,KAAK;AAAA,MAAS;AAAS,eAAO;AAAA,IAClC;AAAA,EACJ;AAAA,EAEQ,kBAAkB,OAAqD;AAC3E,QAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO,KAAK,GAAG;AACnD,aAAO,KAAK,QAAQ,OAAO,KAAK;AAAA,IACpC;AACA,WAAO;AAAA,EACX;AAAA,EAEU,cAAc,OAAwB;AAC5C,YAAQ,IAAI,gDAAgD,KAAK;AACjE,QAAI,KAAK,KAAK;AACV,YAAM,SAAS,KAAK,kBAAkB,KAAK;AAC3C,YAAM,kBAAkB,KAAK,2BAA2B,KAAK;AAC7D,cAAQ,IAAI,4CAA4C,QAAQ,QAAQ,OAAO,eAAe;AAC9F,WAAK,IAAI,WAAW,EAAE,QAAQ,gBAAgB,CAAC;AAAA,IACnD,OAAO;AACH,cAAQ,KAAK,8DAA8D;AAAA,IAC/E;AAAA,EACJ;AAAA,EAEA,iBAAiB,SAA4B;AACzC,QAAI,CAAC,KAAK,OAAO,CAAC,KAAK,OAAQ;AAE/B,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,QAAQ;AAClD,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,SAAS;AACnD,UAAM,KAAK,QAAQ,MAAM,QAAQ,aAAa,QAAQ;AAEtD,QAAI,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,CAAC,IAAI;AACjC,cAAQ,KAAK,oCAAoC,OAAO;AACxD;AAAA,IACJ;AAEA,UAAM,WAAW,EAAE,KAAK,IAAI;AAG5B,QAAI,aAAyB,EAAE,KAAK,GAAG;AACvC,QAAI,KAAK,QAAQ,cAAc;AAC3B,mBAAa,KAAK,QAAQ,aAAa,OAAO;AAAA,IAClD;AAEA,UAAM,gBAA2C;AAAA,MAC7C;AAAA,MACA,KAAK,KAAK;AAAA,MACV,OAAO,OAAO,QAAQ,aAAa,EAAE;AAAA,IACzC;AAEA,QAAI,WAAW,KAAK;AAChB,oBAAc,OAAO;AAAA,QACjB,KAAK,WAAW;AAAA,QAChB,YAAY,WAAW,OAAO,IAAI,KAAK,OAAQ,KAAK,KAAK,WAAW,KAAK,CAAC,GAAG,WAAW,KAAK,CAAC,CAAC,IAAI;AAAA,QACnG,QAAQ,WAAW,SAAS,IAAI,KAAK,OAAQ,KAAK,MAAM,WAAW,OAAO,CAAC,GAAG,WAAW,OAAO,CAAC,CAAC,IAAI;AAAA,MAC1G;AAAA,IACJ;AAEA,UAAM,SAAS,IAAI,KAAK,OAAO,KAAK,OAAO,aAAa;AAGxD,QAAI,UAAU;AACd,QAAI,KAAK,QAAQ,oBAAoB;AACjC,gBAAU,KAAK,QAAQ,mBAAmB,OAAO;AAAA,IACrD;AACA,UAAM,aAAa,IAAI,KAAK,OAAO,KAAK,WAAW,EAAE,QAAQ,CAAC;AAE9D,WAAO,YAAY,SAAS,MAAM;AAC9B,iBAAW,KAAK,KAAK,KAAK,MAAM;AAAA,IACpC,CAAC;AAED,SAAK,QAAQ,IAAI,IAAI,EAAE,QAAQ,WAAW,CAAC;AAC3C,SAAK,cAAc,IAAI,OAAO;AAAA,EAClC;AAAA,EAEA,oBAAoB,SAA4B;AAC5C,UAAM,KAAK,QAAQ,MAAM,QAAQ,aAAa,QAAQ;AACtD,UAAM,WAAW,KAAK,QAAQ,IAAI,EAAE;AAEpC,QAAI,CAAC,UAAU;AACX,WAAK,iBAAiB,OAAO;AAC7B;AAAA,IACJ;AAEA,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,QAAQ;AAClD,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,SAAS;AAEnD,QAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG;AAE5B,UAAI,KAAK,QAAQ,oBAAoB;AACjC,iBAAS,WAAW,WAAW,KAAK,QAAQ,mBAAmB,OAAO,CAAC;AAAA,MAC3E;AAGA,UAAI,KAAK,QAAQ,cAAc;AAC3B,cAAM,aAAa,KAAK,QAAQ,aAAa,OAAO;AACpD,YAAI,WAAW,KAAK;AAChB,mBAAS,OAAO,QAAQ;AAAA,YACpB,KAAK,WAAW;AAAA,YAChB,YAAY,WAAW,OAAO,IAAI,KAAK,OAAQ,KAAK,KAAK,WAAW,KAAK,CAAC,GAAG,WAAW,KAAK,CAAC,CAAC,IAAI;AAAA,YACnG,QAAQ,WAAW,SAAS,IAAI,KAAK,OAAQ,KAAK,MAAM,WAAW,OAAO,CAAC,GAAG,WAAW,OAAO,CAAC,CAAC,IAAI;AAAA,UAC1G,CAAC;AAAA,QACL;AAAA,MACJ;AAGA,WAAK,gBAAgB,IAAI,SAAS,KAAK,GAAG;AAAA,IAC9C;AAAA,EACJ;AAAA,EAEA,aAAa,IAA2B;AACpC,UAAM,OAAO,KAAK,QAAQ,IAAI,EAAE;AAChC,QAAI,MAAM;AACN,WAAK,OAAO,OAAO,IAAI;AACvB,WAAK,QAAQ,OAAO,EAAE;AAAA,IAC1B;AACA,SAAK,aAAa,OAAO,EAAE;AAAA,EAC/B;AAAA,EAEA,kBAAwB;AACpB,SAAK,QAAQ,QAAQ,UAAQ,KAAK,OAAO,OAAO,IAAI,CAAC;AACrD,SAAK,QAAQ,MAAM;AACnB,SAAK,aAAa,MAAM;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAMQ,cAAc,IAAqB,SAAsB;AAC7D,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,QAAQ;AAClD,UAAM,MAAM,OAAO,QAAQ,OAAO,QAAQ,SAAS;AACnD,UAAM,WAAW,OAAO,QAAQ,SAAS,CAAC;AAC1C,UAAM,KAAK,KAAK,IAAI;AAEpB,SAAK,aAAa,IAAI,IAAI;AAAA,MACtB,SAAS,EAAE,KAAK,KAAK,KAAK,GAAG;AAAA,MAC7B,SAAS;AAAA,MACT,OAAQ,WAAW,MAAQ;AAAA;AAAA,MAC3B,SAAS,WAAW,OAAO,QAAQ,UAAU,CAAC,CAAC;AAAA,MAC/C,iBAAiB,EAAE,KAAK,KAAK,IAAI;AAAA,MACjC,cAAc,YAAY,IAAI;AAAA,MAC9B,WAAW,KAAK,iBAAiB,OAAO;AAAA,IAC5C,CAAC;AAAA,EACL;AAAA,EAEQ,gBAAgB,IAAqB,SAAsB,QAAgB,QAAgB;AAC/F,UAAM,QAAQ,KAAK,aAAa,IAAI,EAAE;AACtC,QAAI,CAAC,OAAO;AACR,WAAK,cAAc,IAAI,OAAO;AAC9B;AAAA,IACJ;AAEA,UAAM,MAAM,YAAY,IAAI;AAC5B,UAAM,WAAW,OAAO,QAAQ,SAAS,CAAC;AAE1C,UAAM,UAAU,EAAE,GAAG,MAAM,QAAQ;AACnC,UAAM,UAAU,EAAE,KAAK,QAAQ,KAAK,QAAQ,IAAI,IAAI;AAEpD,QAAI,MAAM,SAAS;AACf,YAAM,OAAO;AAAA,QACT,EAAE,KAAK,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,IAAI;AAAA,QACjD,EAAE,KAAK,QAAQ,KAAK,OAAO;AAAA,MAC/B;AACA,UAAI,OAAO,GAAG;AACV,cAAM,UAAU,eAAe,MAAM,QAAQ,KAAK,MAAM,QAAQ,KAAK,QAAQ,MAAM;AAAA,MACvF,WAAW,QAAQ,QAAQ;AACvB,cAAM,UAAU,OAAO,QAAQ,MAAM;AAAA,MACzC;AAAA,IACJ;AAEA,UAAM,QAAS,WAAW,MAAQ;AAClC,UAAM,YAAY,KAAK,iBAAiB,OAAO;AAG/C,UAAM,cAAc;AAAA,MAChB,EAAE,KAAK,MAAM,gBAAgB,KAAK,KAAK,MAAM,gBAAgB,IAAI;AAAA,MACjE,EAAE,KAAK,QAAQ,KAAK,OAAO;AAAA,IAC/B;AAEA,QAAI,cAAc,KAAK;AACnB,YAAM,kBAAkB,EAAE,KAAK,QAAQ,KAAK,OAAO;AAAA,IACvD;AAAA,EACJ;AAAA,EAEQ,iBAAiB,SAA+B;AACpD,UAAM,QAAQ,OAAO,QAAQ,SAAS,CAAC;AACvC,QAAI,QAAQ,cAAc,SAAS;AAC/B,UAAI,OAAO,QAAQ,KAAK,MAAM,WAAY,QAAO;AACjD,UAAI,OAAO,QAAQ,KAAK,MAAM,UAAW,QAAO;AAAA,IACpD;AACA,QAAI,OAAO,QAAQ,SAAS,EAAE,YAAY,MAAM,UAAU;AACtD,YAAM,SAAS,OAAO,QAAQ,aAAoB;AAClD,UAAI,WAAW,SAAS,WAAW,SAAS,WAAW,WAAW,WAAW,IAAK,QAAO;AACzF,UAAI,WAAW,QAAQ,WAAW,QAAQ,WAAW,UAAU,WAAW,IAAK,QAAO;AAAA,IAC1F;AACA,WAAO,QAAQ;AAAA,EACnB;AAAA,EAEQ,yBAAyB;AAC7B,QAAI,OAAO,WAAW,YAAa;AAEnC,UAAM,UAAU,CAAC,SAAiB;AAC9B,UAAI,CAAC,KAAK,kBAAmB,MAAK,oBAAoB;AACtD,YAAM,QAAQ,OAAO,KAAK;AAC1B,WAAK,oBAAoB;AAEzB,YAAM,KAAK,KAAK,IAAI,OAAO,GAAG,IAAI;AAElC,WAAK,aAAa,QAAQ,CAAC,OAAO,OAAO;AACrC,cAAM,aAAa,KAAK,QAAQ,IAAI,EAAE;AACtC,YAAI,CAAC,WAAY;AAEjB,YAAI,MAAM,WAAW;AACjB,gBAAM,kBAAkB;AAAA,YACpB,MAAM;AAAA,YACN,EAAE,KAAK,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,IAAI;AAAA,YACjD;AAAA,UACJ;AAAA,QACJ,OAAO;AACH,gBAAM,YAAY;AAAA,YACd,MAAM,gBAAgB;AAAA,YACtB,MAAM,gBAAgB;AAAA,YACtB,MAAM;AAAA,YACN,MAAM;AAAA,YACN;AAAA,UACJ;AACA,gBAAM,kBAAkB;AAAA,YACpB;AAAA,YACA,EAAE,KAAK,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,IAAI;AAAA,YACjD;AAAA,UACJ;AAAA,QACJ;AAEA,YAAI,KAAK,UAAU,WAAW,QAAQ;AAClC,gBAAM,SAAS,IAAI,KAAK,OAAO,KAAK,OAAO,MAAM,gBAAgB,KAAK,MAAM,gBAAgB,GAAG;AAC/F,qBAAW,OAAO,YAAY,MAAM;AAAA,QACxC;AAAA,MACJ,CAAC;AAED,WAAK,uBAAuB,sBAAsB,OAAO;AAAA,IAC7D;AAEA,SAAK,uBAAuB,sBAAsB,OAAO;AAAA,EAC7D;AAAA,EAEA,iBAAiB,UAA+B;AAC5C,QAAI,CAAC,KAAK,OAAO,CAAC,KAAK,UAAU,CAAC,SAAS,OAAQ;AACnD,UAAM,SAAS,IAAI,KAAK,OAAO,KAAK,aAAa;AACjD,QAAI,WAAW;AACf,aAAS,QAAQ,OAAK;AAClB,YAAM,MAAM,OAAO,EAAE,OAAO,EAAE,QAAQ;AACtC,YAAM,MAAM,OAAO,EAAE,OAAO,EAAE,SAAS;AACvC,UAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG;AAC5B,eAAO,OAAO,EAAE,KAAK,IAAI,CAAC;AAC1B,mBAAW;AAAA,MACf;AAAA,IACJ,CAAC;AACD,QAAI,UAAU;AACV,WAAK,IAAI,UAAU,MAAM;AAAA,IAC7B;AAAA,EACJ;AAAA,EAEA,UAAU,KAAa,KAAmB;AACtC,QAAI,KAAK,KAAK;AACV,WAAK,IAAI,UAAU,EAAE,KAAK,IAAI,CAAC;AAAA,IACnC;AAAA,EACJ;AAAA,EAEA,QAAQ,MAAoB;AACxB,QAAI,KAAK,KAAK;AACV,WAAK,IAAI,QAAQ,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,aAA0B;AACvC,QAAI,CAAC,KAAK,OAAO,CAAC,KAAK,OAAQ;AAC/B,SAAK,kBAAkB;AAEvB,QAAI,CAAC,eAAe,YAAY,WAAW,EAAG;AAE9C,UAAM,OAAoC,CAAC;AAC3C,UAAM,SAAS,IAAI,KAAK,OAAO,KAAK,aAAa;AAEjD,gBAAY,QAAQ,WAAS;AACzB,YAAM,MAAM,OAAO,MAAM,GAAG;AAC5B,YAAM,MAAM,OAAO,MAAM,OAAO,MAAM,GAAG;AACzC,UAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG;AAC5B,cAAM,MAAM,EAAE,KAAK,IAAI;AACvB,aAAK,KAAK,GAAG;AACb,eAAO,OAAO,GAAG;AAGjB,YAAI,MAAM,aAAa,SAAS;AAC5B,cAAI,UAAU;AACd,cAAI,MAAM,SAAS,cAAe,WAAU;AAAA,mBACnC,MAAM,SAAS,eAAgB,WAAU;AAElD,cAAI,SAAS;AACT,kBAAM,SAAS,IAAI,KAAK,OAAQ,KAAK,OAAO;AAAA,cACxC,UAAU;AAAA,cACV,KAAK,KAAK;AAAA,cACV,MAAM;AAAA,gBACF,KAAK;AAAA,gBACL,YAAY,IAAI,KAAK,OAAQ,KAAK,KAAK,IAAI,EAAE;AAAA,gBAC7C,QAAQ,IAAI,KAAK,OAAQ,KAAK,MAAM,IAAI,EAAE;AAAA,cAC9C;AAAA,cACA,OAAO,MAAM;AAAA,YACjB,CAAC;AACD,iBAAK,YAAY,KAAK,MAAM;AAAA,UAChC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,SAAK,kBAAkB,IAAI,KAAK,OAAO,KAAK,SAAS;AAAA,MACjD;AAAA,MACA,UAAU;AAAA,MACV,aAAa;AAAA,MACb,eAAe;AAAA,MACf,cAAc;AAAA,MACd,KAAK,KAAK;AAAA,IACd,CAAC;AAED,SAAK,IAAI,UAAU,MAAM;AAAA,EAC7B;AAAA,EAEA,oBAA0B;AACtB,QAAI,KAAK,iBAAiB;AACtB,WAAK,gBAAgB,OAAO,IAAI;AAChC,WAAK,kBAAkB;AAAA,IAC3B;AACA,SAAK,YAAY,QAAQ,OAAK,EAAE,OAAO,IAAI,CAAC;AAC5C,SAAK,cAAc,CAAC;AACpB,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,oBAA0B;AACtB,QAAI,KAAK,kBAAkB;AACvB,2BAAqB,KAAK,gBAAgB;AAC1C,WAAK,mBAAmB;AAAA,IAC5B;AACA,QAAI,KAAK,eAAe;AACpB,WAAK,cAAc,OAAO,IAAI;AAAA,IAClC;AACA,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,YAAY,aAAoB,gBAAgB,KAAO,UAA6B;AAChF,QAAI,CAAC,KAAK,OAAO,CAAC,KAAK,UAAU,CAAC,eAAe,YAAY,SAAS,EAAG;AACzE,SAAK,kBAAkB;AACvB,SAAK,WAAW,YAAY;AAE5B,UAAM,UAAU,YAAY,IAAI,QAAM;AAAA,MAClC,KAAK,OAAO,EAAE,GAAG;AAAA,MACjB,KAAK,OAAO,EAAE,OAAO,EAAE,GAAG;AAAA,IAC9B,EAAE,EAAE,OAAO,OAAK,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC;AAE9C,SAAK,gBAAgB,KAAK,qBAAqB,SAAS,aAAa;AACrE,SAAK,qBAAqB,YAAY,IAAI;AAC1C,SAAK,aAAa;AAClB,SAAK,WAAW;AAGhB,QAAI,CAAC,KAAK,eAAe;AACrB,WAAK,gBAAgB,IAAI,KAAK,OAAO,KAAK,OAAO;AAAA,QAC7C,KAAK,KAAK;AAAA,QACV,MAAM;AAAA;AAAA;AAAA;AAAA,UAIF,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAOL,YAAY,IAAI,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE;AAAA,UAC5C,QAAQ,IAAI,KAAK,OAAO,KAAK,MAAM,IAAI,EAAE;AAAA,QAC7C;AAAA,QACA,QAAQ;AAAA,MACZ,CAAC;AAAA,IACL,OAAO;AACH,WAAK,cAAc,OAAO,KAAK,GAAG;AAAA,IACtC;AAKA,QAAI,KAAK,cAAc,SAAS,GAAG;AAC/B,YAAM,QAAQ,KAAK,cAAc,CAAC,EAAE,SAAS,SAAS,KAAK,cAAc,CAAC,EAAE,QAAQ,KAAK,cAAc,CAAC,EAAE;AAC1G,WAAK,cAAc,YAAY,KAAK;AAAA,IACxC;AAEA,UAAM,UAAU,CAAC,SAAiB;AAC9B,UAAI,KAAK,UAAU;AACf,aAAK,mBAAmB,sBAAsB,OAAO;AACrD;AAAA,MACJ;AAEA,YAAM,UAAU,OAAO,KAAK,qBAAqB,KAAK;AACtD,UAAI,WAAW,KAAK,oBAAoB;AACpC,cAAM,OAAO,KAAK,cAAc,KAAK,cAAc,SAAS,CAAC;AAC7D,cAAM,MAAM,KAAK,SAAS,SAAS,KAAK,MAAM,KAAK;AACnD,aAAK,eAAe,YAAY,GAAG;AACnC,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB;AAAA,MACJ;AAEA,YAAM,UAAU,KAAK,cAAc,KAAK,OAAK,WAAW,EAAE,aAAa,UAAU,EAAE,OAAO;AAC1F,UAAI,WAAW,KAAK,eAAe;AAC/B,YAAI,QAAQ,SAAS,QAAQ;AACzB,eAAK,cAAc,YAAY,QAAQ,QAAQ;AAAA,QACnD,WAAW,QAAQ,SAAS,QAAQ;AAChC,gBAAM,aAAa,UAAU,QAAQ;AACrC,gBAAM,WAAW,aAAa,QAAQ;AACtC,gBAAM,MAAM,QAAQ,MAAM,OAAO,QAAQ,IAAI,MAAM,QAAQ,MAAM,OAAO;AACxE,gBAAM,MAAM,QAAQ,MAAM,OAAO,QAAQ,IAAI,MAAM,QAAQ,MAAM,OAAO;AACxE,eAAK,cAAc,YAAY,EAAE,KAAK,IAAI,CAAC;AAAA,QAC/C;AAAA,MACJ;AACA,WAAK,mBAAmB,sBAAsB,OAAO;AAAA,IACzD;AAEA,SAAK,mBAAmB,sBAAsB,OAAO;AAAA,EACzD;AAAA,EAEQ,qBAAqB,SAAgB,eAAuB;AAChE,UAAM,WAAkB,CAAC;AACzB,UAAM,iBAAiB;AACvB,UAAM,sBAAsB;AAC5B,QAAI,cAAmB;AAEvB,aAAS,IAAI,GAAG,IAAI,QAAQ,SAAS,GAAG,KAAK;AACzC,YAAM,KAAK,QAAQ,CAAC;AACpB,YAAM,KAAK,QAAQ,IAAI,CAAC;AACxB,YAAM,OAAO,kBAAkB,IAAI,EAAE;AAErC,UAAI,OAAO,gBAAgB;AACvB,YAAI,CAAC,aAAa;AACd,wBAAc,EAAE,MAAM,QAAQ,UAAU,IAAI,UAAU,oBAAoB;AAC1E,mBAAS,KAAK,WAAW;AAAA,QAC7B;AAAA,MACJ,OAAO;AACH,sBAAc;AACd,iBAAS,KAAK,EAAE,MAAM,QAAQ,OAAO,IAAI,KAAK,IAAI,UAAU,MAAM,UAAU,EAAE,CAAC;AAAA,MACnF;AAAA,IACJ;AAEA,UAAM,gBAAgB,SAAS,OAAO,OAAK,EAAE,SAAS,MAAM,EAAE,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,UAAU,CAAC;AACpG,UAAM,eAAe,SAAS,OAAO,OAAK,EAAE,SAAS,MAAM,EAAE,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,UAAU,CAAC;AACnG,UAAM,oBAAoB,KAAK,IAAI,KAAM,gBAAgB,YAAY;AAErE,aAAS,QAAQ,OAAK;AAClB,UAAI,EAAE,SAAS,QAAQ;AACnB,UAAE,WAAY,EAAE,WAAW,gBAAiB;AAAA,MAChD;AAAA,IACJ,CAAC;AAED,QAAI,cAAc;AAClB,aAAS,QAAQ,OAAK;AAClB,QAAE,YAAY;AACd,qBAAe,EAAE;AACjB,QAAE,UAAU;AAAA,IAChB,CAAC;AAED,SAAK,qBAAqB;AAC1B,WAAO;AAAA,EACX;AAAA,EAEA,UAAgB;AACZ,QAAI,KAAK,qBAAsB,sBAAqB,KAAK,oBAAoB;AAC7E,SAAK,kBAAkB;AACvB,SAAK,gBAAgB;AACrB,QAAI,KAAK,gBAAiB,MAAK,gBAAgB,OAAO,IAAI;AAC1D,SAAK,MAAM;AAAA,EACf;AACJ;","names":[]}